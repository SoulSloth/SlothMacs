#+title: SlothMacs Config
#+PROPERTY: header-args:emacs-lisp :tangle ./init.el :mkdirp yes

This configuraiton is my ongoing effort to improve my tooling.

* System-centric configs
** Fix shell path on Mac
#+begin_src emacs-lisp
(when (string= system-type "darwin")
  (use-package exec-path-from-shell)
    (exec-path-from-shell-initialize))
#+end_src

** Dired defaults on Mac

#+begin_src emacs-lisp
(if (eq system-type 'darwin)
    (let ((gls (executable-find "gls")))
      (when gls
	(setq insert-directory-program gls
	      dired-listing-switches "-aBhl --group-directories-first"))))

#+end_src

* Basic UI Configuration
Basic UI Setup for most of our environment
** Disable The Defaults
These optoins steal my precious screen space
#+begin_src emacs-lisp
  (setq inhibit-startup-message t) ; no startup message
        (scroll-bar-mode -1) ; Disable scroll bar
        (tool-bar-mode -1) ; Disable tool bar
        (tooltip-mode -1) ; Disable tool tips
        (menu-bar-mode -1) ; Disable the menu bar
#+end_src

** Column and Line Numbers
Display Column number in the mode line and line numbers by default
#+begin_src emacs-lisp
  ;; Display column number in Mode line
  (column-number-mode)
  ;; Display line numbers by default
  (global-display-line-numbers-mode t)
#+end_src

*** Disable line numbers in certain modes

Disable line numbers when we're in these modes were it isn't as relevent
#+begin_src emacs-lisp
(dolist (mode '(org-mode-hook
		markdown-mode-hook
                term-mode-hook
                shell-mode-hook
                vterm-mode-hook
                eshell-mode-hook
                dired-mode-hook
		help-mode-hook
                ))
 (add-hook mode (lambda () (display-line-numbers-mode 0))))
#+end_src

#+RESULTS:

** Fringes
Left and right display fringes
#+begin_src emacs-lisp
  (set-fringe-mode 10)
#+end_src

** Fix The Bottom Gap In DWM
Resizes the window based on pixel size instead of font size

Otherwise we get a nasty gap at the bottom of our window
#+begin_src emacs-lisp
  (setq frame-resize-pixelwise t)
#+end_src

** Font Configuration
Current font configuration.
#+begin_src emacs-lisp
(defvar sloth/default-font-size 140)
(set-face-attribute 'default nil :font "Source code pro" :family "sans" :height 100 :width 'normal)

;; Haven't found an easy analog to Nimbus Mono PS on Mac
(when (not (string= system-type "darwin"))
 (set-face-attribute 'default nil :font "Nimbus Mono PS" :family "monospace" :height 115))
#+end_src

*** TODO Complete Font Setup
**** TODO Research how font families work

**** TODO Gather a collection of good fonts

**** TODO Create a font config and tangle it to our local dotfile

* Package
Package.el and use-pacakge installation + configuration

** Require =Package=

Requires the =package.el= file that'll help us install things from various pacakge archives like =elpa=, =melpa=, and the org =elpa=
#+begin_src emacs-lisp
  (require 'package)
#+end_src

** Package Sources
Set the =package-archives= variable up with =org=, =elpa=, and the =melpa= package archives
#+begin_src emacs-lisp
  (setq package-archives '(("org" .  "http://orgmode.org/elpa/") ;; Org mode latest
                             ("elpa" . "http://elpa.gnu.org/packages/") ;; Standard elisp packages
                             ("melpa" . "https://melpa.org/packages/"))) ;;Milkypostman's Emacs Lisp Pacakge Archive
#+end_src

** Initialize Packages
Loads and activates our installed elisp packages
#+begin_src emacs-lisp
      (package-initialize)
#+end_src

** Refresh Package contents
=package-archive-contents= is a variable that contains the cache of all archives versions described in =package-archives= (see above in [[*Package Sources][Package Sources]]). If it's value is =nil= we call =pacakge-refresh-contents= in order to grab a fresh copy of the latest archive listings.

Useful for avoiding cases were 
#+begin_src emacs-lisp
  (unless package-archive-contents
    (package-refresh-contents))
#+end_src

** Require =Use-Package=

[[https://github.com/jwiegley/use-package][use-package]] is a macro that allows us to do many boiler-plate things like config packages after they're loaded, adding hooks to when our package does things, and activating package modes when opening certain files.
#+begin_src emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))

  (require 'use-package)

  (setq use-package-always-ensure t)
#+end_src

* Flyspell
 Minor emacs mode for spell checking, Built-in
** Enable Flyspell in all modes
- Normal =flyspell mode= for text mode stuff which gives us the checking we'd expect
- =prog-mode= for programming buffers to check spelling errors in comments
#+begin_src emacs-lisp
(add-hook 'text-mode-hook 'flyspell-mode)
(add-hook 'prog-mode-hook 'flyspell-prog-mode)
#+end_src

** Flyspell Correct
Provides a nice ivy-interface for flyspell corrections. 

#+begin_src emacs-lisp
(use-package flyspell-correct-ivy)
#+end_src

* No littering

Put temporary and backup files into =/etc= instead
#+begin_src emacs-lisp
(use-package no-littering)

#+end_src

** Keep temp emacs files in =var=

#+begin_src emacs-lisp
 (setq auto-save-file-name-transforms
	`((".*" ,(no-littering-expand-var-file-name "auto-save/") t)))
#+end_src

* General Key Mappings
=general.el= provides analgous macros to =use-package= in the key mapping space
** use-package general
Our installation of general.el proper
#+begin_src emacs-lisp
(use-package general
;; Creates qeuivalent vim mapping functions
  :config
  (general-evil-setup t)
  ;; see https://github.com/noctuid/general.el#automatic-key-unbinding
  :config
  (general-auto-unbind-keys)
  ;; Add our leader keys
  :config
  (general-create-definer sloth/leader-keys
    :keymaps '(normal insert visual emacs)
    ;; EVIL spacemacs goodness
    :prefix "SPC"
    :global-prefix "C-SPC"))
#+end_src

** Leader-keys
We define our leader-keys that will be passed to =general-create-definer=

Unsure as to why, but we get an error on start-up that leader-keys are not defined if we put this definition BEFORE the =use-package= def of =general=. 
#+begin_src emacs-lisp
(defun open-project-file ()
  "Prompts the user for a file in ~/org/projects and opens it"
  (interactive)
  (find-file
   (ivy-read "Open Project File: "
	       (directory-files "~/org/projects/" t "\.org")
	      :require-match "yes" )))


(defun open-emacs-conf ()
  "Opens the emacs literate conf"
  (interactive)
  (find-file "~/.emacs.d/Emacs.org"))

(defun open-tasks-file ()
   "Opens the emacs literate conf"
   (interactive)
   (find-file "~/org/dailies.org"))

(sloth/leader-keys
 "SPC" '(counsel-M-x :which-key "Execute Command" )
 ;; Opening relevent org files
 "a" '(:ignore a :which-key "Open file")
 "ad" '(open-tasks-file :which-key "open tasks")
 "ae" '(open-emacs-conf :which-key "open emacs config")
 "ap" '(open-project-file :which-key "open project file")

 ;; Flyspell
 "d" '(:ignore d :which-key "Flyspell")
 "dd" '(flyspell-correct-wrapper :which-key "Auto-correct word")
 
 ;; Magit
 "g" '(:ignore g :which-key "Magit")
 "gs" '(magit-status :which-key "Status")
 "gl" '(magit-log-current :which-key "Status")
 
 ;; Buffers
 "b" '(switch-to-buffer :which-key "Switch to buffer")
 
 ;; toggles 
 "t" '(:ignore t :which-key "toggles")
 "tt" '(counsel-load-theme :which-key "choose theme")
 
 ;; Clojure CIDER commands
 "s" '(:ignore s :which-key "cider")
 "sj" '(cider-jack-in :which-key "CIDER jack-in")
 "sq" '(cider-quit :which-key "CIDER quit")
 "se" '(cider-eval-region :which-key "cider eval region")
 "ss" '(cider-insert-region-in-repl :which-key "cider send region to repl")
 "sf" '(cider-format-buffer :which-key "cider format buffer")
 "sb" '(cider-load-buffer :which-key "cider load buffer")

 ;; General Project management
 "li" '(lsp-ivy-workspace-symbol :which-key "ivy workspace symbol")
 "p" '(projectile-switch-project :which-key "projectile switch project")
 "f" '(counsel-projectile-grep :which-key "projectile-grep")
 
 ;; Org
 "o" '(:ignore o :which-key "org")
 "od" '(org-display-inline-images :which-key "display inline images")
 "or" '(org-remove-inline-images :which-key "remove inline images")

 ;; Org Capture
 "c" '(org-capture :which-key "org capture"))
#+end_src


*** TODO We can probably macro these =find-file= functions...

*** TODO Completions for project files shouldn't have to be the entire path 🤔
- Even if passed a hash-map =completling-read= will only complete and return keys...

*** TODO If completion for project isn't found, create the project file?

* Swiper
Swiper allows us to quickly search files for regex candidates
#+begin_src emacs-lisp
(unless (package-installed-p 'swiper)
  (package-install 'swiper))

(require 'swiper)
#+end_src

* Completion
Various completion packages which work together(sometimes).
** Ivy
Ivy provides better mini buffer completions for packages like =swiper= and =counsel=
*** Main Ivy
The main Ivy package
#+begin_src emacs-lisp
  (use-package ivy
      :diminish
      :bind (("C-s" . swiper)
             :map ivy-minibuffer-map
             ("TAB" . ivy-alt-done)
             ("C-l" . ivy-alt-done)
             ("C-k" . ivy-next-line)
             :map ivy-switch-buffer-map
             ("C-k" . ivy-previous-line)
             ("C-l" . ivy-done)
             ("C-d" . ivy-switch-buffer-kill)
             :map ivy-reverse-i-search-map
             ("C-k" . ivy-previous-line)
             ("C-d" . ivy-reverse-i-search-kill))
      :config
      (ivy-mode 1))
#+end_src

*** Ivy-rich
=Ivy-rich= gives us some nice metadata along with the competion
#+begin_src emacs-lisp
;; Give us some more info in completions
  (use-package ivy-rich
      :init
      (ivy-rich-mode 1))
#+end_src

** Counsel
=Counsel= takes many emacs commands and fronts them to ivy ones like switching buffer, finding files, and seeing buffer history. Also works with =projectile= for my personal favorite command =counsel-projectile-grep=.
#+begin_src emacs-lisp
  (use-package counsel
    :bind (("M-x" . counsel-M-x)
           ("C-x b" . counsel-ibuffer)
           ("C-x C-f" . counsel-find-file)
           :map minibuffer-local-map
           ("C-r" . 'counsel-minibuffer-history)))
#+end_src

** which-key

=which-key= gives us a pop-up window that will tell us the competions for any partial commands we have entered 
#+begin_src emacs-lisp
;; which-key for when we forget command completions
  (use-package which-key
    :init (which-key-mode)
    :diminish which-key-mode
    :config (setq which-key-idle-delay 0.3))
#+end_src

** Hydra
=Hydra= provides us with a nice minor mode that will allow us to repeat certain families of commads over and over again like zooming in and out
#+begin_src emacs-lisp
;; Get Hydra
  (use-package hydra)

  ;; Defining a hydra meny
    (defhydra hydra-text-scale (:timeout 4)
      "scale text"
      ("j" text-scale-increase "in")
      ("k" text-scale-decrease "out")
      ("f" nil "finished" :exit t))

  ;; Add it to our leader-keys
    (sloth/leader-keys
      "ts" '(hydra-text-scale/body :which-key "scale text"))
#+end_src

* Projectile

Projectile project management faculties.

Consider install =fd= for [[https://docs.projectile.mx/projectile/configuration.html#alien-indexing][faster finds.]]
#+begin_src emacs-lisp
  (use-package projectile
    :diminish projectile-mode
    :config (projectile-mode)
    ;; Use git grep in source controlled projects
    ;; Invaluable for ignoring temp files
    :config (setq projectile-use-git-grep t)
    :custom ((projectile-completion-system 'ivy))
    :bind-keymap
    ("C-c p" . projectile-command-map)
    :init
    ;; This lets us rapidly switch between different projects in our
    ;; work directory
    (when (file-directory-p "~/projects")
      (setq projectile-project-search-path '("~/projects")))
    (setq projectile-swith-project-action #'projectile-dired))

;; Play nice with Counsel
  (use-package counsel-projectile
    :config (counsel-projectile-mode))
#+end_src


** TODO Need to add directories like "clj-kondo" to the ignore for finds/greps

* Magit
Magit for a lovely facade over git's command line interface
#+begin_src emacs-lisp
  (use-package magit
    :custom
  ;; Just show the magit window in the same buffer
    (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1))
#+end_src

* Ediff

Ediff mode provides diffing utilities, mainly for use with Magit here.
#+begin_src emacs-lisp
(use-package ediff)
#+end_src

* Helpful
Helpful provides more helpful help messages
#+begin_src emacs-lisp
(use-package helpful
    :ensure t
    :custom
    (counsel-describe-function-function #'helpful-callable)
    (counsel-describe-variable-function #'helpful-variable)
    :bind
    ([remap describe-function] . helpful-callable)
    ([remap describe-command] . helpful-command)
    ([remap describe-variable] . helpful-variable)
    ([remap describe-key] . helpful-key))
#+end_src

* DOOM Modeline
Currently just DOOM at the moment.

Ensure you run  =M-x all-the-icons-install-fonts= for this to work
#+begin_src emacs-lisp
 (use-package all-the-icons)

(use-package doom-modeline
  :ensure t
  :init (doom-modeline-mode 1)
  :custom ((doom-modeline-height 10)))
#+end_src

* Evil, Vim keybindings for emacs
Gives us a vi layer over emacs.
** Evil proper
#+begin_src emacs-lisp
  (use-package evil
    :ensure t
    :init
    ;; evil-collections required sets
    (setq evil-want-integration t)
    (setq evil-want-keybinding nil)
    ;; Give us back up from emacs
    (setq evil-want-C-u-scroll t)
    (setq evil-want-C-i-jump nil)
    ;; Use evil in the minibuffer
    (setq evil-want-minibuffer t)
    ;; Get undo-redo functionality
    (setq evil-undo-system 'undo-redo)
    :config
    (evil-mode 1)
    ;; Exit to evil normal state with C-g instead of having to hit esc
    :config
    (define-key evil-insert-state-map (kbd "C-g") 'evil-normal-state))

;; Use visual line motions even outside of visual-line-mode buffers
(evil-global-set-key 'motion "j" 'evil-next-visual-line)
(evil-global-set-key 'motion "k" 'evil-previous-visual-line)
;; Set the state when we enter certain modes
(evil-set-initial-state 'messages-buffer-mode 'normal)
(evil-set-initial-state 'dashboard-mode 'normal)
#+end_src

** Evil collection
Evil collections provides extra evil faculties in missing areas
#+begin_src emacs-lisp
(use-package evil-collection
  ;; Only load after evil
  :after evil
  ;; init
  :config
  (evil-collection-init))
#+end_src

** Evil Matchit
Better =%= matching for evil
#+begin_src emacs-lisp
(use-package evil-matchit
 :after evil
 :config (global-evil-matchit-mode 1))
#+end_src

* Theme
Themes tried:
- monokai: pretty, but code blocks in org blended a bit too much with the background and the code highlighting didn't look right.
- gruvbox: Liking this so far, code highlighting stands out nicely on the dark background
  
#+begin_src emacs-lisp
(use-package gruvbox-theme)
(load-theme 'gruvbox t)
#+end_src

* Commenting

Using evil-nerd-commenter since the default emacs package has some weird behavoir at times
#+begin_src emacs-lisp
  (use-package evil-nerd-commenter
    :bind ("M-/" . evilnc-comment-or-uncomment-lines))
#+end_src

* Languages

[[https://emacs-lsp.github.io/lsp-mode/][Emacs LSP Mode Site]]: For all your language finding needs
The hotkey is set to =C-c l=
Lsp servers must be installed for these modes to work. For linux machines, the command =lsp-install-server= will easily handle it. I've had no such luck on mac and have had to typically install such servers with =brew=. Be sure to check the lsp mode site for specifics.

** Language Server Protocol

#+begin_src emacs-lisp
(defun sloth/lsp-mode-setup ()
  (setq lsp-headerline-breadcrumb-segments '(path-up-to-project file symbols))
  (lsp-headerline-breadcrumb-mode))

(use-package lsp-mode
  :commands (lsp lsp-deferred)
  :hook (lsp-mode . sloth/lsp-mode-setup)
  :init
  (setq lsp-keymap-prefix "C-c l")  ;; Or 'C-l', 's-l'
  :config
  (lsp-enable-which-key-integration t))
#+end_src

*** LSP UI

Sideline IDE editor items
#+begin_src emacs-lisp
(use-package lsp-ui
  :hook (lsp-mode . lsp-ui-mode)
  :custom
  (lsp-ui-doc-position 'bottom))
#+end_src

*** LSP Ivy
Find symbols in the workspace quickly:
#+begin_src emacs-lisp :tangle no
    (use-package lsp-ivy)
#+end_src

** Company Mode

Using company mode to enable a selection box on tab completions
#+begin_src emacs-lisp
  (use-package company
  :after lsp-mode
  :hook (lsp-mode . company-mode)
  :bind (:map company-active-map
         ("<tab>" . company-complete-selection))
        (:map lsp-mode-map
         ("<tab>" . company-indent-or-complete-common))
  :custom
  (company-minimum-prefix-length 1)
  (company-idle-delay 0.0)) 

  (use-package company-box
  :hook (company-mode . company-box-mode))
#+end_src

** Typescript

- Install with =npm i -g typescript-language-server=
- Also Typescript if it's not present =npm i -g typescript=
#+begin_src emacs-lisp
  (use-package typescript-mode
    :mode "\\.ts\\'" ;; Start up any time we open a fiel with .ts exentsion
    :hook (typescript-mode . lsp-deferred) ;; Don't startup the server until buffer is visible
    :config (setq typescript-indent-level 2))
#+end_src

** Python

- Install with =pip install 'python-lsp-server[all]'=
- [[https://github.com/python-lsp/python-lsp-server][Project github]]
- Ensure =python= is on PATH!

#+begin_src emacs-lisp
  (use-package python-mode
    :ensure t
    :hook (python-mode . lsp-deferred)
    :custom
    (python-shell-interpreter "python"))
#+end_src

*** Useful keystrokes
- =run-python= : run a python shell in =*Python*=
- =python-shell-send-region= : Sends a python expression to the =*Python*= buffer
** Java

[[https://github.com/emacs-lsp/lsp-java][Github page for lsp-java]]

#+begin_src emacs-lisp
(use-package lsp-java
  :ensure t
  :hook (java-mode . lsp-deferred))
#+end_src

** Clojure
Currently working off of [[https://ccann.github.io/2015/10/18/cider.html][Clojure At Sea's configuraiton example]]
*** Clojure mode
#+begin_src emacs-lisp
(use-package clojure-mode
  :ensure t
  :mode (("\\.clj\\'" . clojure-mode)
         ("\\.edn\\'" . clojure-mode))
  :hook (clojure-mode . lsp-deferred)) 
#+end_src

*** Cider clojure emacs tooling
#+begin_src emacs-lisp
  (use-package cider
    :ensure t
    :defer t
    :diminish subword-mode
    :config
    (setq nrepl-log-messages t)
    ;; I don't type things into the repl much
    (setq cider-repl-pop-to-buffer-on-connect nil)
    (setq cider-repl-display-help-banner nil)
    (cider-repl-toggle-pretty-printing))
#+end_src

#+RESULTS:
: t

**** Errors
error in process filter: run-hooks: Symbol’s function definition is void: clj-refactor-mode
error in process filter: Symbol’s function definition is void: clj-refactor-mode

*** Clojure-essential-ref for clojure doc lookups
#+begin_src emacs-lisp
(use-package clojure-essential-ref)
#+end_src

*** TODO  set up a function for sending a form to the cider-repl for evaluation
** Go
#+begin_src emacs-lisp
(use-package go-mode
  :ensure t
  :mode (("\\.go\\'" . go-mode))
  :hook ((before-save . gofmt-before-save) (go-mode . lsp-deferred))
  )
#+end_src

*** Install
**** Install =go= and the Golang lsp server: =gopls =:  =go install golang.org/x/tools/gopls@latest=
**** Add go to path
#+begin_src shell :tangle no
export GOPATH="$(go env GOPATH)"
export PATH="${PATH}:${GOPATH}/bin"
#+end_src

** Docker
#+begin_src emacs-lisp
(use-package docker-compose-mode)
#+end_src

** Scala
#+begin_src emacs-lisp
(use-package scala-mode
   :interpreter
     ("scala" . scala-mode)
   :mode (("\\.scala\\'" . scala-mode))
     )
#+end_src

** Terraform
#+begin_src emacs-lisp
(use-package terraform-mode)
#+end_src

* General Programming Utils
** Rainbow delimiters
Pretty rainbow delimiters to help balence parens
#+begin_src emacs-lisp
  ;; Rainbow delimiters
  (use-package  rainbow-delimiters
  :hook (prog-mode . rainbow-delimiters-mode))
#+end_src

* Org Mode
I use =org-mode= to take notes, write blogs, and create litearte coding "books" with =org-babel=
** Org Proper
Having the `org-ellipsis key be 🎈 started as a joke, but I found it pretty useful so I'm keeping it
#+begin_src emacs-lisp
(defun sloth/org-mode-setup ()
  ;; Indent according to outline structure
  (org-indent-mode)
  (variable-pitch-mode 1)
  ;; Word Wrap
  (visual-line-mode 1)
  (linum-mode 0))

(use-package org-bullets
    :after org
    :hook (org-mode . org-bullets-mode)
    :custom
    (org-bullets-bullet-list '("◉" "○" "●" "○" "●" "○" "●")))

(defun sloth/org-font-setup ()
  ;; Replace list hyphen with dot
  (font-lock-add-keywords 'org-mode
                          '(("^ *\\([-]\\) "
                             (0 (prog1 () (compose-region (match-beginning 1) (match-end 1)
							  "•")))))))


(use-package org
:hook (org-mode . sloth/org-mode-setup)
           :config (setq org-ellipsis " 🎈"
                         ;; hides formatting markers
                         org-hide-emphasis-markers t)
	       ;; Don't auto-indent when we RET after a line
           (setq org-edit-src-content-indentation 0)
	       (setq org-export-with-toc nil)
           (sloth/org-font-setup))
#+end_src

#+RESULTS:
| efs/org-mode-visual-fill | org-tempo-setup | (lambda nil (add-hook 'after-save-hook #'efs/org-babel-tangle-config)) | org-bullets-mode | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-show-all append local] 5] | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-babel-show-result-all append local] 5] | org-babel-result-hide-spec | org-babel-hide-all-hashes | #[0 \301\211\207 [imenu-create-index-function org-imenu-get-tree] 2] | efs/org-mode-setup | (lambda nil (display-line-numbers-mode 0)) |

** Org Face Configuration
[[https://zzamboni.org/post/beautifying-org-mode-in-emacs/][taken from zzamboni]]

#+begin_src emacs-lisp
  (custom-theme-set-faces
   'user
   '(org-block ((t (:inherit fixed-pitch))))
   '(org-code ((t (:inherit (shadow fixed-pitch)))))
   '(org-document-info ((t (:foreground "dark orange"))))
   '(org-document-info-keyword ((t (:inherit (shadow fixed-pitch)))))
   '(org-indent ((t (:inherit (org-hide fixed-pitch)))))
   '(org-link ((t (:foreground "royal blue" :underline t))))
   '(org-meta-line ((t (:inherit (font-lock-comment-face fixed-pitch)))))
   '(org-property-value ((t (:inherit fixed-pitch))) t)
   '(org-special-keyword ((t (:inherit (font-lock-comment-face fixed-pitch)))))
   '(org-table ((t (:inherit fixed-pitch :foreground "#83a598"))))
   '(org-tag ((t (:inherit (shadow fixed-pitch) :weight bold :height 0.8))))
   '(org-verbatim ((t (:inherit (shadow fixed-pitch))))))

#+end_src

** Tags
#+begin_src emacs-lisp
(setq org-tag-alist
      '((:startgroup)
	;; Mutually exclusive tags go here
	(:endgroup)
       ("@errand" . ?E)
       ("@home" . ?H)
       ("@work" . ?W)
       ("planning" . ?p)))
#+end_src

** Refile Targets
#+begin_src emacs-lisp
    (setq org-refile-targets
          '(("~/org/archive.org" :maxlevel . 1)
            ("~/org/tasks.org" :maxlevel . 1)))
  
  (advice-add 'org-refile :after `org-save-all-org-buffers)
#+end_src

** Keywords
#+begin_src emacs-lisp
(setq org-todo-keywords
      '((sequence
	 ;; Active states
	 "TODO(t)" "NEXT(n)"
	 "|"
	 ;; Done state
	 "DONE(d!)")
	(sequence "BACKLOG(b)" "PLAN(p)" "READY(r)" "ACTIVE(a)" "REVIEW(v)" "WAIT(w@/!)" "HOLD(h)" "|" "COMPLETED(c)" "CANC(k@)")))
#+end_src

** Capture Templates
=org-capture= allows you to quickly pull up an org buffer which will have some filled-in values that you can immediately edit and save without interrupting your work. Said files can be automatically organized by date, filling highlighted text, link to the file you're capturing in, or even put data into a org table for processing.
#+begin_src emacs-lisp
(setq org-capture-templates
    `(("d" "Daily Planning")
      ;; Our plan for the day
      ;; Currently prompting the user for the datetime just so I can set it to tomarrow,
      ;; But I guess I can plan a couple days in advance
      ("dd" "Daily Todos" entry (file+olp+datetree "~/org/dailies.org" "dailies")
           "* Planned  %?\n  %U\n %a\n %i" :empty-lines 0 :time-prompt t)
      ;; Record what actually happens on the day we're doing things
      ("da" "Daily activities" entry (file+olp+datetree "~/org/dailies.org" "dailies")
           "* %U  %i \ \n" :empty-lines 0)

      ;; Location for useful/interesting code snippits
      ("c" "Capture code snippet"
        entry (file+olp "~/org/code.org" "Snippets")
           "* %^{What is this?} :%^{Language|clojure|emacs-lisp|python}:  %?\n  %U\n  %a\n #+begin_src %\\2 \n %i \n #+end_src\n" :empty-lines 1)

      ("j" "Journal Entries")
      ("jj" "Journal" entry
           (file+olp+datetree "~/org/journal.org")
           "\n* %<%I:%M %p> - Journal :journal:\n\n%?\n\n"
           ;; ,(dw/read-file-as-string "~/Notes/Templates/Daily.org")
           :clock-in :clock-resume
           :empty-lines 1)
      
      ("k" "Kata Capture")
      ("kk" "Daily Kata" entry
       (file+olp+datetree "~/org/kata.org")
        "\n* %<%I:%M %p> - Kata :kata:\n\n%?\n\n"
        :clock-in :clock-resume
        :empty-lines 1)
      
      ("i" "Improvement Ideas")
      ("ii" "Tooling Improvement" entry (file+olp "~/org/improvement.org" "Tooling")
           "* TODO %?\n  %U\n  %a\n  %i" :empty-lines 1)
      ("il" "Learning Improvement" entry (file+olp "~/org/improvement.org" "Learning")
           "* TODO %?\n  %U\n  %a\n  %i" :empty-lines 1)

      ("m" "Metrics Capture")
      ("ms" "Sleep" table-line (file+headline "~/org/metrics.org" "Sleep")
       "| %U | %^{How Are You Feeling} | %^{Sleep/Wake?} |" :kill-buffer t)
      
      ("jm" "Meeting" entry
           (file+olp+datetree "~/org/journal.org")
           "* %<%I:%M %p> - %a :meetings:\n\n%?\n\n"
           :clock-in :clock-resume
           :empty-lines 1)
      ("jl" "WorkLogs" entry
           (file+olp+datetree "~/org/journal.org")
           "* %<%I:%M %p> - %a :Logs:\n\n%?\n\n"
           :clock-in :clock-resume
           :empty-lines 0)
      
      ("w" "Workflows")
      ("we" "Checking Email" entry (file+olp+datetree "~/org/journal.org")
           "* Checking Email :email:\n\n%?" :clock-in :clock-resume :empty-lines 1)
      
      
      ("mw" "Weight" table-line (file+headline "~/org/metrics.org" "Weight")
       "| %U | %^{Weight} | %^{Notes} |" :kill-buffer t)

      ("t" "Tasks / Projects")
      ("tt" "Task" entry (file+olp "~/org/tasks.org" "Inbox")
           "* TODO %?\n  %U\n  %a\n  %i" :empty-lines 1)))

(define-key global-map (kbd "C-c k")
(lambda () (interactive) (org-capture nil "kk")))

(define-key global-map (kbd "C-c t")
(lambda () (interactive) (org-capture nil "ii")))

(define-key global-map (kbd "C-c j")
(lambda () (interactive) (org-capture nil "jj")))
#+end_src

*** TODO The capture snippet for code blocks has a slight bug where if you capture that snippet template it will EXPAND the templates within the =%i= initial content

** Org Agenda
#+begin_src emacs-lisp
    (setq org-agenda-start-with-log-mode t)
    (setq org-log-done 'time)
    ;; Fold log entries into drawer
    (setq org-log-into-drawer t)

    (setq org-agenda-files '("~/org/tasks.org"
                             "~/org/birthdays.org"
                             "~/org/habits.org"
                             )) 

    (require 'org-habit)
    (add-to-list 'org-modules 'org-habit)
    (setq org-habit-graph-column 60)
  
  
#+end_src

***  Agenda Custom Commands
#+begin_src emacs-lisp
(setq org-agenda-custom-commands
        '(("d" "Dashboard"
           ((agenda "" ((org-deadline-warning-days 7)))
            (todo "NEXT"
                  ((org-agenda-overriding-header "Next Tasks")))
            (tags-todo "agenda/ACTIVE" ((org-agenda-overriding-header "Active Projects")))))

          ("n" "Next Tasks"
           ((todo "NEXT"
                  ((org-agenda-overriding-header "Next Tasks")))))

          ("W" "Work Tasks" tags-todo "+work-email")

          ;; Low-effort next actions
          ("e" tags-todo "+TODO=\"NEXT\"+Effort<15&+Effort>0"
           ((org-agenda-overriding-header "Low Effort Tasks")
            (org-agenda-max-todos 20)
            (org-agenda-files org-agenda-files)))

          ("w" "Workflow Status"
           ((todo "WAIT"
                  ((org-agenda-overriding-header "Waiting on External")
                   (org-agenda-files org-agenda-files)))
            (todo "REVIEW"
                  ((org-agenda-overriding-header "In Review")
                   (org-agenda-files org-agenda-files)))
            (todo "PLAN"
                  ((org-agenda-overriding-header "In Planning")
                   (org-agenda-todo-list-sublevels nil)
                   (org-agenda-files org-agenda-files)))
            (todo "BACKLOG"
                  ((org-agenda-overriding-header "Project Backlog")
                   (org-agenda-todo-list-sublevels nil)
                   (org-agenda-files org-agenda-files)))
            (todo "READY"
                  ((org-agenda-overriding-header "Ready for Work")
                   (org-agenda-files org-agenda-files)))
            (todo "ACTIVE"
                  ((org-agenda-overriding-header "Active Projects")
                   (org-agenda-files org-agenda-files)))
            (todo "COMPLETED"
                  ((org-agenda-overriding-header "Completed Projects")
                   (org-agenda-files org-agenda-files)))
            (todo "CANC"
                  ((org-agenda-overriding-header "Cancelled Projects")
                   (org-agenda-files org-agenda-files)))))))
#+end_src

** Auto-tangle Configuration Files
#+begin_src emacs-lisp
;; Automatically tangle our Emacs.org config file when we save it
(defun sloth/org-babel-tangle-config ()
  (when (string-equal (buffer-file-name)
                      (expand-file-name "~/.emacs.d/Emacs.org"))
    
    ;; Dynamic scoping to the rescue
    (let ((org-confirm-babel-evaluate nil))
      (org-babel-tangle)))) 

(add-hook 'org-mode-hook (lambda () (add-hook 'after-save-hook #'sloth/org-babel-tangle-config)))
#+end_src

** Org-Babel Config
*** Golang support provided by [[https://github.com/pope/ob-go][ob-go]]
#+begin_src emacs-lisp
  (use-package ob-go)
#+end_src

*** Load Languages
[[https://orgmode.org/worg/org-contrib/babel/languages/index.html][Currently supported languages can be found in the Org documentation]]

 #+begin_src emacs-lisp
 (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (python . t)
     (clojure . t)
     (shell . t)
     (plantuml . t)
     (go . t)
     (js .t)))

   (setq org-confirm-babel-evaluate nil)
 #+end_src

 #+RESULTS:

*** Backends
**** CIDER
cider provides support for clojure emacs tooling
#+begin_src emacs-lisp
(setq org-babel-clojure-backend 'cider)
#+end_src

**** Plantuml
Plant uml diagrams jar file needs to be downloaded:
https://eschulte.github.io/babel-dev/DONE-integrate-plantuml-support.html
#+begin_src emacs-lisp
(if (string= system-type "darwin")
     (setq org-plantuml-jar-path
       (expand-file-name "/usr/local/bin/plantuml.jar"))
     (setq org-plantuml-jar-path
       (expand-file-name "/usr/bin/plantuml.jar")))
#+end_src

*** PlantUml hook
Display the images created by the plantUml org-babel calls
#+begin_src emacs-lisp
(setq org-babel-after-execute-hook 'org-display-inline-images)
#+end_src

**** TODO Really this should only run /after/ the calls for plantUml

*** Structure Templates
#+begin_src  emacs-lisp
;; This is needed as of Org 9.2
(require 'org-tempo)

(add-to-list 'org-structure-template-alist '("sh" . "src shell"))
(add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
(add-to-list 'org-structure-template-alist '("py" . "src python"))
(add-to-list 'org-structure-template-alist '("go" . "src go"))
(add-to-list 'org-structure-template-alist '("clj" . "src clojure"))
(add-to-list 'org-structure-template-alist '("yl" . "src yaml"))
(add-to-list 'org-structure-template-alist '("conf" . "src conf"))
(add-to-list 'org-structure-template-alist '("pl" . "src plantuml :file diagram.png"))
(add-to-list 'org-structure-template-alist '("js" . "src js"))
#+end_src

** Visual Fill
#+begin_src emacs-lisp
(defun sloth/org-mode-visual-fill ()
  (setq visual-fill-column-width 125
        visual-fill-column-center-text t)
  (visual-fill-column-mode 1))

(use-package visual-fill-column
  :hook (org-mode . sloth/org-mode-visual-fill))
#+end_src

** Org-Roam
Org-Roam provides us with tooling to create linked knowledge bases in org files
#+begin_src emacs-lisp
(use-package org-roam
	     :ensure t
	     :init
	     (setq org-roam-v2-ack t)
	     :custom
	     (org-roam-directory "~/org/roam")
	     :bind (("C-c n l" . org-roam-buffer-toggle)
	     ("C-c n f" . org-roam-node-find)
	     ("C-c n i" . org-roam-node-insert)
	     :map org-mode-map
	     ("C-M-i" . completion-at-point))
	     :config
	     (org-roam-setup))
#+end_src

*** Deft
#+begin_src emacs-lisp
(use-package deft
  :after org
  :bind
  ("C-c n d" . deft)
  :custom
  (deft-recursive t)
  (deft-use-filter-string-for-filename t)
  (deft-default-extension "org")
  (deft-directory org-roam-directory))
#+end_src

#+RESULTS:
: deft

* Terminals
** term-mode
=C-c C-k= char mode
#+begin_src emacs-lisp
  (use-package term
  :config
  (setq explicit-shell-file-name "zsh")
  (setq explicit-zsh-args '())
  (setq term-prompt-regexp "^[^#$%>\n]*[#$%>] *"))

  (use-package eterm-256color
    :hook (term-mode . eterm-256color-mode))
#+end_src

** vterm

[[https://github.com/akermu/emacs-libvterm#requirements][vterm has a few requirements that need to be installed for it to build properly]]

#+begin_src emacs-lisp
(use-package vterm
  :commands vterm
  :config
  (setq term-prompt-regexp "^[^#$%>\n]*[#$%>] *")  ;; Set this to match your custom shell prompt
  ;;(setq vterm-shell "zsh")                       ;; Set this to customize the shell to launch
  (setq vterm-max-scrollback 10000))
#+end_src

*** Directory and Prompt tracking fixes
Add the following to your =.zshrc= to make directory tracking and prompt tracking work correctly.

[[https://github.com/akermu/emacs-libvterm#directory-tracking-and-prompt-tracking][Taken from the Vterm github]]
#+begin_src shell :tangle no :eval never
vterm_printf() {
    if [ -n "$TMUX" ] && ([ "${TERM%%-*}" = "tmux" ] || [ "${TERM%%-*}" = "screen" ]); then
        # Tell tmux to pass the escape sequences through
        printf "\ePtmux;\e\e]%s\007\e\\" "$1"
    elif [ "${TERM%%-*}" = "screen" ]; then
        # GNU screen (screen, screen-256color, screen-256color-bce)
        printf "\eP\e]%s\007\e\\" "$1"
    else
        printf "\e]%s\e\\" "$1"
    fi
}

vterm_prompt_end() {
    vterm_printf "51;A$(whoami)@$(hostname):$(pwd)"
}
setopt PROMPT_SUBST
PROMPT=$PROMPT'%{$(vterm_prompt_end)%}'
#+end_src

* File Management
** Dired
Dired for managing our filesystem.
*** Dired Proper
Dired, the Directory Editor, allows us to quickly navigate our filesystem, make edits, and perform other useful actions like compressing archives.
#+begin_src emacs-lisp
(use-package dired
;; dired is part of emacs proper so no need to ensure
  :ensure nil
  :init (setq dired-auto-revert-buffer  (lambda (_dir) (null (cdr dired-subdir-alist))))
  :commands (dired dired-jump)
  ;; Jump out of visited file
  :bind (("C-x C-j" . dired-jump))
  ;; `ls` options passed to dir
  :custom (
	   (dired-listing-switches "-agho --group-directories-first")
	   )
  :config
  ;; navigate our dired buffers as if we were using lf
  (evil-collection-define-key 'normal 'dired-mode-map
    "h" 'dired-single-up-directory
    "l" 'dired-single-buffer)
  ;; When on mac, tell dired to use gls
  (when (string= system-type "darwin")
  (setq dired-use-ls-dired t
        insert-directory-program "gls")))

#+end_src

*** dired-single
Allows us to have one dired buffer instead of a new one for each directory
#+begin_src emacs-lisp
  (use-package dired-single)
#+end_src

*** all-the-icons-dired
Give us a bunch of pretty icons for our dired buffer
#+begin_src emacs-lisp
  (use-package all-the-icons-dired
    :hook (dired-mode . all-the-icons-dired-mode))
#+end_src

*** dired-open
Use specific programs to open certain files
#+begin_src emacs-lisp
  (use-package dired-open
    :config
    ;; Doesn't work as expected!
    ;;(add-to-list 'dired-open-functions #'dired-open-xdg t)
    (setq dired-open-extensions '(("png" . "feh")
                                  ("mkv" . "mpv"))))
#+end_src

*** dired-hide-dotfiles
Hide dotfiles, which are usually clutter unless we're configuring something.
#+begin_src emacs-lisp
  (use-package dired-hide-dotfiles
    :hook (dired-mode . dired-hide-dotfiles-mode)
    :config
    (evil-collection-define-key 'normal 'dired-mode-map
      "H" 'dired-hide-dotfiles-mode))
#+end_src
